{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"index.html#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos.html","title":"Encabezados","text":"<pre><code># T\u00edtulo \n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos.html#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos.html#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos.html#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos.html#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos.html#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos.html#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos.html#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos.html#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos.html#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos.html#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos.html#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos.html#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos.html#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos.html#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos.html#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo.html","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo.html#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo.html#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo.html#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo.html#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo.html#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds.html","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds.html#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds.html#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds.html#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds.html#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds.html#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds.html#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds.html#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"presentacion.html","title":"\ud83d\udc4b \u00a1Hola! Soy Carlos Alberto V\u00e1zquez Peraza","text":"<p>\u201cHubo una vez que no chambi\u00e9 por 8 meses; gracias a Dios, al noveno mes nac\u00ed.\u201d \u2728  </p>"},{"location":"presentacion.html#sobre-mi","title":"\ud83e\udeaa Sobre m\u00ed","text":"<ul> <li>Nombre: Carlos Alberto V\u00e1zquez Peraza</li> <li>Edad: 17</li> <li>De: Xalapa, Veracruz, M\u00e9xico \u2014 nacido en C\u00f3rdoba, Veracruz</li> <li>Idiomas: Espa\u00f1ol \u2022 Ingl\u00e9s \u2022 Franc\u00e9s (intermedio)</li> <li>Estudiante de: Mecatr\u00f3nica y M\u00fasica</li> <li>Tecnolog\u00edas que manejo: Python \u2022 C \u2022 C++ \u2022 Rust</li> </ul>"},{"location":"presentacion.html#lo-que-me-gusta","title":"\ud83d\udcab Lo que me gusta","text":"<ul> <li>M\u00fasica: Electro swing</li> <li>Pel\u00edculas: Interestelar \u2022 Nobody</li> <li>Lectura: Terror \u2022 Autoayuda/Desarrollo personal</li> <li>Comidas favoritas: Quecas \u2022 Huevo con frijol</li> <li>Hobbies: Videojuegos \u2022 Estudiar programaci\u00f3n \u2022 Aprender nuevas habilidades</li> </ul>"},{"location":"presentacion.html#lo-que-hago-y-me-mueve","title":"\ud83c\udf31 Lo que hago y me mueve","text":"<ul> <li>Metas personales: Aprender y construir proyectos propios, viajar a Europa (especialmente Alemania), crecer en mecatr\u00f3nica y m\u00fasica</li> <li>Intereses: Tecnolog\u00eda, dise\u00f1o de sistemas, videojuegos, series como rick and morty</li> <li>Me encanta conectar con: Personas curiosas, gamers </li> </ul>"},{"location":"presentacion.html#un-poco-de-mi-mundo","title":"\ud83d\udcf8 Un poco de mi mundo","text":"<p>Momentos que me definen</p> <p>  Mis pap\u00e1s</p> <p>  Mi mam\u00e1 y yo</p> <p>  Yoko y Duquesita (falta Kiki)</p>"},{"location":"presentacion.html#de-donde-vengo","title":"\ud83d\uddfa\ufe0f De d\u00f3nde vengo","text":"<ul> <li>Nac\u00ed en: C\u00f3rdoba, Veracruz</li> <li>Historia breve: He tenido una vida incre\u00edble con altos y bajos; cada experiencia vali\u00f3 la pena para ser quien soy hoy.</li> <li>Familia: Dos hermanas y tres perritas</li> </ul>"},{"location":"presentacion.html#cosas-random-sobre-mi","title":"\ud83e\udde9 Cosas random sobre m\u00ed","text":"<ul> <li>Me encanta jugar juegos de mesa</li> <li>Disfruto ver videos de misterio</li> <li>Me gusta armar y construir cosas</li> <li>Ver pelis con mi mam\u00e1 es de mis planes favoritos</li> </ul>"},{"location":"presentacion.html#viajes-y-suenos","title":"\u2708\ufe0f Viajes y sue\u00f1os","text":"<ul> <li>A\u00fan no he viajado, pero me encantar\u00eda ir a Alemania</li> </ul>"},{"location":"presentacion.html#ahora-mismo","title":"\ud83e\udde0 Ahora mismo","text":"<ul> <li>Estudiando: Mecatr\u00f3nica y teor\u00eda musical</li> <li>Practicando: Proyectos en Python, C/C++ y Rust</li> <li>Escuchando: Electro swing y playlists para concentrarme</li> <li>Aprendiendo: Nuevas habilidades t\u00e9cnicas y creativas</li> </ul>"},{"location":"presentacion.html#ventas-y-mayoreo","title":"\ud83d\uded2 Ventas y mayoreo","text":"<p>Productos y licencias que ofrezco. Escr\u00edbeme para precios actualizados, promociones por volumen y m\u00e9todos de pago.</p> Producto/Servicio Duraci\u00f3n/Presentaci\u00f3n Modalidad Notas Licencia ChatGPT 2 meses Digital Activaci\u00f3n remota Licencia ChatGPT 3 meses Digital Soporte b\u00e1sico Licencia ChatGPT 1 a\u00f1o Digital Renovaci\u00f3n opcional Licencia Perplexity 2 meses Digital Acceso premium Licencia Perplexity 3 meses Digital Consulta guiada Licencia Perplexity 1 a\u00f1o Digital Mejor precio por a\u00f1o Spotify Premium 1 a\u00f1o Digital Cuenta nueva o existente AIProd 1 a\u00f1o (o plan acordado) Digital Confirmar plan disponible MagSafe (accesorios) Mayoreo (packs) F\u00edsico Descuentos por volumen <p>Puedo generar paquetes combinados (por ejemplo, ChatGPT + Spotify + Perplexity) a precio especial por mayoreo. Entrega inmediata en productos digitales.</p>"},{"location":"presentacion.html#contacto-y-redes","title":"\ud83d\udcec Contacto y redes","text":"<ul> <li>Email: mrcavp@gmail.com</li> <li>WhatsApp: 228 496 3952</li> <li>Instagram: @mr_logros</li> </ul>"},{"location":"presentacion.html#mi-emprendimiento","title":"\ud83d\udccc Mi emprendimiento","text":"<p>Comenc\u00e9 vendiendo dulces en la escuela y luego pase a vendedor de mayoreo. Mi sue\u00f1o es tener mi propio negocio alg\u00fan d\u00eda. Gracias por apoyar mi emprendimiento.</p>"},{"location":"presentacion.html#habilidades","title":"\ud83e\uddf0 Habilidades","text":""},{"location":"presentacion.html#lenguajes-de-programacion","title":"Lenguajes de programaci\u00f3n","text":"<p>Python \u2022 C \u2022 C++ \u2022 Rust</p>"},{"location":"presentacion.html#areas-de-fortaleza","title":"\u00c1reas de fortaleza","text":"<p>Matem\u00e1ticas \u2022 F\u00edsica \u2022 Tecnolog\u00eda \u2022 Programaci\u00f3n</p>"},{"location":"Primer%20parcial/Actividad%201.html","title":"LED parpadeante con 555","text":""},{"location":"Primer%20parcial/Actividad%201.html#objetivo","title":"Objetivo","text":"<p>Implementar un oscilador simple con el temporizador 555 para encender y apagar un LED de forma peri\u00f3dica, registrando materiales, conexiones y verificaci\u00f3n.</p>"},{"location":"Primer%20parcial/Actividad%201.html#descripcion-rapida-del-555","title":"Descripci\u00f3n r\u00e1pida del 555","text":"<p>El 555 funciona como generador de onda cuadrada en modo astable: un capacitor se carga y descarga a trav\u00e9s de dos resistencias y la salida (pin 3) conmuta cada vez que el voltaje del capacitor cruza los umbrales internos.</p>"},{"location":"Primer%20parcial/Actividad%201.html#materiales-utilizados","title":"Materiales utilizados","text":"<ul> <li>Protoboard  </li> <li>NE555  </li> <li>LED + resistencia limitadora (220 \u03a9 \u2013 1 k\u03a9)  </li> <li>R1 y R2 para el astable (1 k\u03a9 \u2013 100 k\u03a9 t\u00edpicos)  </li> <li>Capacitor electrol\u00edtico (1 \u00b5F \u2013 470 \u00b5F)  </li> <li>Jumpers  </li> <li>Fuente DC (5\u20139 V)</li> </ul>"},{"location":"Primer%20parcial/Actividad%201.html#conexiones-paso-a-paso","title":"Conexiones paso a paso","text":"<ol> <li>Pin 1 \u2192 GND  </li> <li>Pin 8 \u2192 VCC  </li> <li>Pin 4 (RESET) \u2192 VCC  </li> <li>Unir pines 2 (TRIG) y 6 (THR)  </li> <li>R1 entre VCC y pin 7 (DIS)  </li> <li>R2 entre pin 7 (DIS) y pines 2/6  </li> <li>Capacitor C entre pines 2/6 y GND (positivo a 2/6 si es electrol\u00edtico)  </li> <li>Pin 3 (OUT) \u2192 resistencia \u2192 \u00e1nodo del LED; c\u00e1todo \u2192 GND  </li> <li>Alimentar la tarjeta (VCC y GND a rieles)</li> </ol> <p>Tip: valores grandes de R1/R2/C reducen la frecuencia; valores peque\u00f1os la aumentan.</p>"},{"location":"Primer%20parcial/Actividad%201.html#prueba-y-verificacion","title":"Prueba y verificaci\u00f3n","text":"<ul> <li>Encender la fuente y observar el LED parpadeando.  </li> <li>Si no hay parpadeo, revisar: polaridad del LED y del capacitor, uni\u00f3n 2\u20136, RESET en alto, continuidad de R1/R2 y orientaci\u00f3n del CI.</li> </ul>"},{"location":"Primer%20parcial/Actividad%201.html#evidencias","title":"Evidencias","text":""},{"location":"Primer%20parcial/Actividad%202.html","title":"Blink en ESP32","text":""},{"location":"Primer%20parcial/Actividad%202.html#objetivo","title":"Objetivo","text":"<p>Generar un parpadeo de 1 segundo encendido y 1 segundo apagado en un LED controlado por un GPIO del ESP32.</p>"},{"location":"Primer%20parcial/Actividad%202.html#materiales","title":"Materiales","text":"<ul> <li>ESP32 DOIT DEVKIT V1.</li> <li>LED rojo y resistencia limitadora (~220\u2013330 \u03a9).</li> <li>Protoboard, jumpers y cable USB.</li> </ul>"},{"location":"Primer%20parcial/Actividad%202.html#conexiones","title":"Conexiones","text":"<ol> <li>\u00c1nodo del LED al GPIO 23 a trav\u00e9s de la resistencia.  </li> <li>C\u00e1todo del LED a GND del ESP32.</li> </ol>"},{"location":"Primer%20parcial/Actividad%202.html#codigo","title":"C\u00f3digo","text":"<pre><code>#define LED 23\n\nvoid setup() {\n  pinMode(LED, OUTPUT); // Configura el pin del LED como salida\n}\n\nvoid loop() {\n  digitalWrite(LED, HIGH); // Enciende el LED\n  delay(1000);             // Espera 1 segundo\n  digitalWrite(LED, LOW);  // Apaga el LED\n  delay(1000);             // Espera 1 segundo\n}\n</code></pre>"},{"location":"Primer%20parcial/Actividad%202.html#prueba","title":"Prueba","text":"<ul> <li>Cargar el sketch y observar el parpadeo continuo.  </li> <li>Si no parpadea: comprobar el pin elegido, polaridad del LED y continuidad de la resistencia.</li> </ul>"},{"location":"Primer%20parcial/Actividad%202.html#evidencias","title":"Evidencias","text":""},{"location":"Primer%20parcial/Actividad%203.html","title":"LED con bot\u00f3n en ESP32","text":""},{"location":"Primer%20parcial/Actividad%203.html#objetivo","title":"Objetivo","text":"<p>Encender un LED cuando se presiona un bot\u00f3n, usando un pin de entrada para el pulsador y un pin de salida para el LED, con mensajes por puerto serie.</p>"},{"location":"Primer%20parcial/Actividad%203.html#materiales","title":"Materiales","text":"<ul> <li>ESP32 DOIT DEVKIT V1 y cable USB.</li> <li>LED rojo y resistencia limitadora (~220\u2013330 \u03a9).</li> <li>Pulsador y resistencia de pull\u2011down (~10 k\u03a9) o uso de pull\u2011up interno.</li> <li>Protoboard y jumpers.</li> </ul>"},{"location":"Primer%20parcial/Actividad%203.html#conexiones","title":"Conexiones","text":"<ol> <li>LED: \u00e1nodo al GPIO 12 mediante la resistencia; c\u00e1todo a GND.</li> <li>Bot\u00f3n: un lado a 3V3; el otro al GPIO 34 con resistencia de 10 k\u03a9 a GND (pull\u2011down).    Alternativa: configurar INPUT_PULLUP y llevar el bot\u00f3n a GND.</li> </ol>"},{"location":"Primer%20parcial/Actividad%203.html#codigo","title":"C\u00f3digo","text":"<pre><code>const int led = 12;\nconst int btn = 34;\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(led, OUTPUT);\n  pinMode(btn, INPUT); // si usas pull\u2011up interno, cambia a INPUT_PULLUP\n}\n\nvoid loop() {\n  int estado = digitalRead(btn);\n  if (estado == 1) {\n    digitalWrite(led, 1);\n    Serial.println(\"on\");\n  } else {\n    digitalWrite(led, 0);\n    Serial.println(\"off\");\n  }\n}\n</code></pre>"},{"location":"Primer%20parcial/Actividad%203.html#prueba-y-verificacion","title":"Prueba y verificaci\u00f3n","text":"<ul> <li>Al presionar el bot\u00f3n, el LED enciende y el monitor serie muestra \u201con\u201d; al soltar, \u201coff\u201d.</li> <li>Si hay falsos disparos: comprobar tierra com\u00fan, resistencias, contactos del pulsador y considerar un peque\u00f1o delay o antirrebote por software.</li> </ul>"},{"location":"Primer%20parcial/Actividad%203.html#evidencias","title":"Evidencias","text":""},{"location":"Primer%20parcial/Actividad%204.html","title":"Control de LED por Bluetooth (ESP32)","text":""},{"location":"Primer%20parcial/Actividad%204.html#objetivo","title":"Objetivo","text":"<p>Conectar el ESP32 por Bluetooth cl\u00e1sico (SPP) a un tel\u00e9fono y, al recibir \u201cON\u201d u \u201cOFF\u201d, cambiar el estado de un LED, mostrando en el monitor serie lo recibido.</p>"},{"location":"Primer%20parcial/Actividad%204.html#materiales","title":"Materiales","text":"<ul> <li>ESP32 DOIT DEVKIT V1 e IDE de Arduino.</li> <li>LED y resistencia limitadora (~220\u2013330 \u03a9).</li> <li>Protoboard y jumpers.</li> <li>App de terminal Bluetooth (por ejemplo, \u201cSerial Bluetooth Terminal\u201d).</li> </ul>"},{"location":"Primer%20parcial/Actividad%204.html#conexiones","title":"Conexiones","text":"<ol> <li>LED: \u00e1nodo a un GPIO (ej. 12 o 23) por medio de la resistencia; c\u00e1todo a GND.</li> <li>USB para alimentar el ESP32 y usar el monitor serie.</li> </ol>"},{"location":"Primer%20parcial/Actividad%204.html#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\nbyte led = 12; // o 23\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"el tlacoyo\"); // nombre visible del dispositivo\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    String mensaje = SerialBT.readString();\n    Serial.println(\"Recibido: \" + mensaje);\n\n    if (mensaje == \"ON\") {\n      digitalWrite(led, 1);\n      Serial.println(\"On\");\n    } else if (mensaje == \"OFF\") {\n      digitalWrite(led, 0);\n      Serial.println(\"Off\");\n    }\n  }\n  delay(1000);\n}\n</code></pre>"},{"location":"Primer%20parcial/Actividad%204.html#prueba","title":"Prueba","text":"<ul> <li>Emparejar el tel\u00e9fono con el nombre del ESP32 y abrir la app de terminal.</li> <li>Enviar \u201cON\u201d para encender y \u201cOFF\u201d para apagar; verificar en el monitor serie las cadenas recibidas.</li> </ul>"},{"location":"Primer%20parcial/Actividad%204.html#notas-rapidas","title":"Notas r\u00e1pidas","text":"<ul> <li>Si no aparece el dispositivo, reiniciar el ESP32 y comprobar que el Bluetooth del tel\u00e9fono est\u00e9 activo.</li> <li>Para tolerar may\u00fasculas/min\u00fasculas: usar mensaje.toUpperCase() antes de comparar.</li> <li>Evitar pines solo\u2011entrada para el LED (p. ej., 34\u201339).</li> </ul>"},{"location":"Primer%20parcial/Actividad%204.html#evidencias","title":"Evidencias","text":""},{"location":"Segundo%20Parcial/Actividad%20%205.html","title":"Control de un motor DC con ESP32 y L298N","text":""},{"location":"Segundo%20Parcial/Actividad%20%205.html#objetivo","title":"Objetivo","text":"<p>Variar la velocidad y el sentido de un motor DC con ESP32 y L298N alimentado desde fuente de laboratorio, dejando evidencia del cableado y el sketch. </p>"},{"location":"Segundo%20Parcial/Actividad%20%205.html#conceptos-clave","title":"Conceptos clave","text":"<ul> <li>Frecuencia: ciclos por segundo del PWM.</li> <li>Duty: porcentaje en ALTO que fija la potencia media al motor. </li> <li>Resoluci\u00f3n: pasos del duty (2^bits). </li> </ul>"},{"location":"Segundo%20Parcial/Actividad%20%205.html#materiales","title":"Materiales","text":"<ul> <li>ESP32 con IDE de Arduino. </li> <li>M\u00f3dulo L298N (canal A: ENA, IN1, IN2; OUT1, OUT2). </li> <li>Un motor DC tipo TT. </li> <li>Fuente DC de laboratorio; protoboard y jumpers. </li> </ul>"},{"location":"Segundo%20Parcial/Actividad%20%205.html#conexiones-un-canal","title":"Conexiones (un canal)","text":"<ol> <li>Fuente + \u2192 \u201c12V\u201d del L298N; Fuente \u2212 \u2192 GND del L298N y GND del ESP32 (tierra com\u00fan). </li> <li>Motor \u2192 OUT1 y OUT2 del L298N (canal A).</li> <li>IN1 \u2192 GPIO 18, IN2 \u2192 GPIO 19; ENA (PWM) \u2192 GPIO 21 del ESP32.</li> </ol>"},{"location":"Segundo%20Parcial/Actividad%20%205.html#codigo","title":"C\u00f3digo","text":"<pre><code>#define IN1 18\n#define IN2 19\n#define PWM 21\n\nvoid setup() {\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n  ledcAttach(PWM, 1000, 8); // 1 kHz, 8 bits\n}\n\nvoid loop() {\n  // Adelante\n  digitalWrite(IN1, 1);\n  digitalWrite(IN2, 0);\n  ledcWrite(PWM, 200);\n  delay(4000);\n\n  // Atr\u00e1s\n  digitalWrite(IN1, 0);\n  digitalWrite(IN2, 1);\n  ledcWrite(PWM, 200);\n  delay(4000);\n\n  // Alto\n  ledcWrite(PWM, 0);\n  delay(2000);\n}\n</code></pre>"},{"location":"Segundo%20Parcial/Actividad%20%205.html#verificacion","title":"Verificaci\u00f3n","text":"<ul> <li>Ajustar la fuente y el l\u00edmite de corriente; observar cambio de sentido y velocidad seg\u00fan duty.</li> <li>Si no arranca: revisar GND com\u00fan, jumper de habilitaci\u00f3n ENA.</li> </ul>"},{"location":"Segundo%20Parcial/Actividad%20%205.html#evidencias","title":"Evidencias","text":""},{"location":"Segundo%20Parcial/Actividad%206.html","title":"Control de velocidad con motor DC con ESP32 y L298N","text":""},{"location":"Segundo%20Parcial/Actividad%206.html#objetivo","title":"Objetivo","text":"<p>Controlar un motor DC variando velocidad mediante PWM y fijando direcci\u00f3n con dos pines digitales del ESP32, usando el L298N y una fuente DC con l\u00edmite de corriente. </p>"},{"location":"Segundo%20Parcial/Actividad%206.html#descripcion-rapida","title":"Descripci\u00f3n r\u00e1pida","text":"<ul> <li>El L298N es un puente H: IN1/IN2 definen el sentido y ENA recibe el PWM de velocidad. </li> <li>La fuente mostr\u00f3 ~11.9 V y ~0.20 A durante la prueba del motor TT; el segundo canal qued\u00f3 sin carga. </li> </ul>"},{"location":"Segundo%20Parcial/Actividad%206.html#materiales","title":"Materiales","text":"<ul> <li>Fuente GW Instek GPE\u20113323 (CC/CV, 2 canales).</li> <li>M\u00f3dulo L298N (OUT1\u2013OUT4, VIN 12V, GND, 5V, ENA/IN1/IN2). </li> <li>ESP32 DOIT DEVKIT V1. [attached_file:4]  </li> <li>Motorreductor DC tipo TT, protoboard y jumpers. [attached_file:2]</li> </ul>"},{"location":"Segundo%20Parcial/Actividad%206.html#conexiones","title":"Conexiones","text":"<ol> <li>Fuente + \u2192 \u201c12V\u201d del L298N; fuente \u2212 \u2192 GND del L298N y GND del ESP32 (tierra com\u00fan). </li> <li>Motor \u2192 OUT1 y OUT2 (canal A del L298N). </li> <li>IN1 \u2192 GPIO 25 (ESP32) e IN2 \u2192 GPIO 26 para direcci\u00f3n. </li> <li>ENA \u2192 GPIO 27 para PWM (1 kHz, 8 bits).  </li> <li>Verificar polaridades y jumper \u201c5V\u2011EN\u201d seg\u00fan el m\u00f3dulo; mantener GND com\u00fan siempre.</li> </ol>"},{"location":"Segundo%20Parcial/Actividad%206.html#codigo","title":"C\u00f3digo","text":"<pre><code>#define in1 25\n#define in2 26\n#define pwm 27\n\nvoid setup() {\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  ledcAttach(pwm, 1000, 8); // 1 kHz, 8 bits\n}\n\nvoid loop() {\n  // Acelera\n  for (int i = 0; i &lt;= 255; i++) {\n    ledcWrite(pwm, i);\n    digitalWrite(in1, 1);\n    digitalWrite(in2, 0);\n    delay(10);\n  }\n  // Desacelera\n  for (int i = 255; i &gt;= 0; i--) {\n    ledcWrite(pwm, i);\n    digitalWrite(in1, 1);\n    digitalWrite(in2, 0);\n    delay(10);\n  }\n}\n</code></pre>"},{"location":"Segundo%20Parcial/Actividad%206.html#parametros-y-notas","title":"Par\u00e1metros y notas","text":"<ul> <li>Usar ~12 V como entrada al L298N y ajustar l\u00edmite de corriente para cubrir el pico de arranque del motor.  </li> <li>Si no gira: revisar GND com\u00fan, estado de ENA, inversi\u00f3n de IN1/IN2 y l\u00edmite de corriente de la fuente. </li> </ul>"},{"location":"Segundo%20Parcial/Actividad%206.html#evidencias","title":"Evidencias","text":""},{"location":"Segundo%20Parcial/Actvidad%207.html","title":"Control de servomotores con ESP32","text":""},{"location":"Segundo%20Parcial/Actvidad%207.html#objetivo","title":"Objetivo","text":"<p>Mover un micro servo tipo SG90/Steren con se\u00f1ales PWM de 50 Hz generadas por el ESP32, mapeando \u00e1ngulos a pulsos de 1\u20132 ms y validando alimentaci\u00f3n desde fuente DC de laboratorio. </p>"},{"location":"Segundo%20Parcial/Actvidad%207.html#descripcion-rapida","title":"Descripci\u00f3n r\u00e1pida","text":"<ul> <li>Un servo est\u00e1ndar usa 50 Hz: 1 ms \u2248 0\u00b0, 1.5 ms \u2248 90\u00b0, 2 ms \u2248 180\u00b0; la alimentaci\u00f3n t\u00edpica es ~5 V y requiere GND com\u00fan con la se\u00f1al. </li> <li>El montaje muestra ESP32 + protoboard, servo micro y fuente GW Instek con canal ajustado a 12 V para laboratorio, mientras el servo recibe ~5 V regulados/USB y la se\u00f1al desde un GPIO. </li> </ul>"},{"location":"Segundo%20Parcial/Actvidad%207.html#materiales","title":"Materiales","text":"<ul> <li>ESP32 DOIT DEVKIT V1.   </li> <li>Micro servo (Steren S07-180/SG90 equivalente). </li> <li>Fuente GW Instek GPE\u20113323 para pruebas y referencia de tierra; USB para l\u00f3gica/5 V. </li> <li>Protoboard y jumpers; cableado de tres hilos del servo: rojo=Vcc, caf\u00e9/negro=GND, naranja=se\u00f1al. </li> </ul>"},{"location":"Segundo%20Parcial/Actvidad%207.html#conexiones","title":"Conexiones","text":"<ol> <li>Vcc del/los servos a 5 V regulados; nunca alimentar servos desde 3.3 V del ESP32. </li> <li>GND del 5 V de servos unido al GND del ESP32 y de la fuente (tierra com\u00fan). </li> <li>Se\u00f1al del servo a un GPIO del ESP32 (ejemplo GPIO 15); para dos servos usar dos GPIOs independientes. </li> </ol>"},{"location":"Segundo%20Parcial/Actvidad%207.html#codigo","title":"C\u00f3digo","text":"<pre><code>#define SERVO1 15\nint grados = 0;\nint duty = 0;\n\nvoid setup() {\n  // Canal de 50 Hz y resoluci\u00f3n de 12 bits (0\u20134095)\n  ledcAttachChannel(SERVO1, 50, 12, 0);\n}\n\nvoid loop() {\n  for (int i = 0; i &lt;= 180; i += 10) {\n    grados = i;\n    // map 0\u2013180\u00b0 a ~1.0\u20132.0 ms en 20 ms (50 Hz) \u2192 ~205\u2013410 ticks a 12 bits\n    duty = map(grados, 0, 180, 205, 410);\n    ledcWrite(SERVO1, duty);\n    delay(1000);\n  }\n  delay(1000);\n}\n</code></pre>"},{"location":"Segundo%20Parcial/Actvidad%207.html#notas-practicas","title":"Notas pr\u00e1cticas","text":"<ul> <li>Si el servo tiembla: compartir GND, usar cables cortos y subir corriente disponible en 5 V; evitar alimentar desde el pin 5V del ESP32 si el consumo es alto.   </li> <li>Para varios servos: duplicar la conexi\u00f3n de Vcc y se\u00f1al a distintos GPIOs y prever una fuente de 5 V dedicada con suficiente corriente. </li> </ul>"},{"location":"Segundo%20Parcial/Actvidad%207.html#evidencias","title":"Evidencias","text":""},{"location":"Tercer%20parcial/Balanza.html","title":"Plataforma Stewart - An\u00e1lisis Completo","text":""},{"location":"Tercer%20parcial/Balanza.html#1-objetivo-del-sistema","title":"1. Objetivo del sistema","text":"<p>El sistema busca mantener una pelota roja en el centro de un plato circular montado sobre una plataforma tipo Stewart con 3 servos distribuidos a 120\u00b0. La c\u00e1mara detecta plato y pelota; el c\u00f3digo en Python calcula la inclinaci\u00f3n necesaria mediante PID y cinem\u00e1tica inversa; el ESP32 ejecuta los \u00e1ngulos recibidos y mueve los servos.</p> <p>En la interfaz principal (Deteccion_final.jpg) se observa:</p> <p></p> <p>Se ve: - Plato detectado (borde verde). - Centro del plato con c\u00edrculo amarillo/naranja y zona muerta. - Pelota roja con l\u00ednea azul hacia el centro. - HUD con <code>Kp, Ki, Kd</code>, rangos de \u00e1ngulos, \u00e1ngulos actuales y errores normalizados.</p>"},{"location":"Tercer%20parcial/Balanza.html#2-deteccion-del-plato-houghcircles-y-mascara-circular","title":"2. Detecci\u00f3n del plato (HoughCircles) y m\u00e1scara circular","text":"<p>El plato se detecta con <code>cv2.HoughCircles</code> sobre una imagen en escalar de grises suavizada:</p> <ul> <li>Conversi\u00f3n y suavizado:</li> <li><code>gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</code></li> <li> <p><code>blurred = cv2.GaussianBlur(gray, (5,5), 0)</code></p> </li> <li> <p>Par\u00e1metros Hough:</p> </li> <li><code>dp = 0.8</code>: el acumulador de Hough tiene 80% de la resoluci\u00f3n, buena precisi\u00f3n sin ser tan pesado.</li> <li><code>minDist = 280</code>: asegura que solo se detecte un c\u00edrculo grande, evita dobles detecciones.</li> <li><code>param1 = 165</code>: umbral alto de Canny, solo se usan bordes muy definidos (borde del plato).</li> <li><code>param2 = 15</code>: votos m\u00ednimos en el acumulador; bajar este valor hace que aparezcan muchos falsos c\u00edrculos, subirlo hace que deje de detectar.</li> <li><code>minRadius = 130</code>, <code>maxRadius = 211</code>: rango de radios aproximado para el plato.</li> </ul> <p>Se elige el c\u00edrculo de mayor radio de la lista de candidatos; si hay ruido o sombras, estos par\u00e1metros hacen que aun as\u00ed el borde m\u00e1s grande sea el del plato.</p> <p>Para que el c\u00edrculo no \u201csalte\u201d entre cuadros, se aplica un filtro exponencial:</p> <ul> <li><code>plato_cx_f = \u03b1*plato_cx + (1-\u03b1)*plato_cx_f</code> con <code>\u03b1 = 0.9</code>.</li> <li>Esto significa 90% de nuevo valor, 10% de historia; la posici\u00f3n se suaviza pero responde r\u00e1pido.</li> </ul> <p>Con el centro y radio filtrados se genera la m\u00e1scara circular:</p> <ul> <li>M\u00e1scara en blanco y negro del tama\u00f1o del frame, con un c\u00edrculo blanco en la zona del plato y el resto negro.</li> <li>Se usa <code>cv2.bitwise_and</code> para dejar negro todo lo que est\u00e9 fuera del plato; esto garantiza que la detecci\u00f3n de la pelota se haga solo sobre el \u00e1rea \u00fatil.</li> </ul> <p>Se dibujan dos c\u00edrculos:</p> <ul> <li>Uno con radio <code>plato_r_f</code> (borde verde).</li> <li>Uno interno con radio peque\u00f1o, la zona muerta del centro (amarillo/naranja); si la pelota cae dentro, el sistema no corrige para no oscilar.</li> </ul>"},{"location":"Tercer%20parcial/Balanza.html#3-deteccion-de-la-pelota-roja-y-calculo-del-error","title":"3. Detecci\u00f3n de la pelota roja y c\u00e1lculo del error","text":"<p>Con el frame enmascarado, se detecta el color rojo usando espacio HSV:</p> <ul> <li>Se definen dos rangos de rojo:</li> <li><code>[0, 150, 50]</code> a <code>[8, 255, 255]</code> (rojo bajo).</li> <li><code>[170, 150, 50]</code> a <code>[179, 255, 255]</code> (rojo alto).</li> <li>Se hace <code>inRange</code> para cada rango y luego se suman las m\u00e1scaras.</li> </ul> <p>Para reducir ruido:</p> <ul> <li>Se aplica una apertura morfol\u00f3gica (OPEN) con kernel el\u00edptico 5x5 que elimina peque\u00f1as manchas blancas.</li> <li>Se aplica cierre (CLOSE) con el mismo kernel para unir huecos dentro de la mancha de la pelota.</li> </ul> <p>Posteriormente:</p> <ul> <li>Se buscan contornos y se filtran por \u00e1rea (por ejemplo, entre 100 y 5000 p\u00edxeles).</li> <li>De los contornos v\u00e1lidos se escoge el de mayor \u00e1rea como la pelota.</li> <li>Se calculan los momentos de ese contorno y su centroide <code>(cx, cy)</code>.</li> </ul> <p>El error en p\u00edxeles se define como:</p> <ul> <li><code>errX_raw = cx - plato_cx_f</code> (positivo si la pelota est\u00e1 a la derecha).</li> <li><code>errY_raw = cy - plato_cy_f</code> (positivo si la pelota est\u00e1 hacia abajo).</li> </ul> <p>Para que el error sea independiente del tama\u00f1o f\u00edsico del plato:</p> <ul> <li>Se divide por el radio filtrado <code>plato_r_f</code>, obteniendo:</li> <li><code>errX_norm = errX_raw / plato_r_f</code>.</li> <li><code>errY_norm = errY_raw / plato_r_f</code>.</li> <li>Esto produce un error normalizado en el rango aproximado <code>[-1, +1]</code>, donde 1 significa que la pelota est\u00e1 al borde del plato en una direcci\u00f3n dada.</li> </ul> <p>Estos errores normalizados se filtran suavemente:</p> <ul> <li><code>errX_f = \u03b1_err*errX_norm + (1-\u03b1_err)*errX_f</code> con <code>\u03b1_err = 0.6</code>.</li> <li>El error filtrado reacciona r\u00e1pido a cambios pero sin a\u00f1adir demasiado ruido al PID.</li> </ul> <p>Si la pelota sale del plato o ya no se detecta:</p> <ul> <li>El error se pone a cero.</li> <li>Se resetean las integrales y errores previos del PID para evitar windup (acumulaci\u00f3n excesiva de integral).</li> </ul>"},{"location":"Tercer%20parcial/Balanza.html#4-control-pid-y-zona-muerta","title":"4. Control PID y zona muerta","text":"<p>Cada eje (X e Y) utiliza un PID discreto con ganancia ajustable en tiempo real mediante los slicers de la ventana \u201cPID Tuner\u201d (<code>Slicer_PID.jpg</code>):</p> <p></p> <p>En el loop:</p> <ul> <li>Se leen los valores de tres trackbars:</li> <li><code>\"Kp x10\"</code> \u2192 <code>Kp = slider / 10.0</code>.</li> <li><code>\"Ki x100\"</code> \u2192 <code>Ki = slider / 100.0</code>.</li> <li><code>\"Kd x10\"</code> \u2192 <code>Kd = slider / 10.0</code>.</li> <li>Estos se asignan a <code>pid_x</code> y <code>pid_y</code>, por lo que se puede afinar el controlador sin recompilar.</li> </ul> <p>El PID calcula:</p> <ul> <li><code>output = Kp*e + Ki*integral + Kd*derivative</code> con:</li> <li>Anti-windup: la integral est\u00e1 limitada a un rango como <code>[-50, 50]</code>.</li> <li>Saturaci\u00f3n de la salida: por ejemplo, <code>[-20, +20]</code> grados de inclinaci\u00f3n m\u00e1ximos.</li> </ul> <p>La entrada al PID no es el error normalizado directo, sino escalado:</p> <ul> <li><code>errX_input = errX_f * 100</code>.</li> <li><code>errY_input = errY_f * 100</code>.</li> </ul> <p>Se implementa una zona muerta de error (<code>DEADZONE_ERR_INPUT</code>):</p> <ul> <li>Si <code>abs(errX_input) &lt; DEADZONE_ERR_INPUT</code>, se fuerza <code>errX_input = 0</code>.</li> <li>Esto evita que peque\u00f1as variaciones aleatorias causen correcciones continuas y vibraciones en los servos.</li> </ul> <p>Salida corregida:</p> <ul> <li><code>theta_X = -pid_x.update(errX_input)</code>.</li> <li><code>theta_Y = -pid_y.update(errY_input)</code>.</li> </ul> <p>El signo negativo es clave: el PID ve el error positivo, pero la inclinaci\u00f3n debe ser hacia el lado contrario para que la pelota ruede de vuelta al centro.</p> <p>Finalmente, <code>theta_X</code> y <code>theta_Y</code> se limitan a un rango razonable, por ejemplo <code>[-25, +25]</code> grados.</p>"},{"location":"Tercer%20parcial/Balanza.html#5-cinematica-inversa-de-3-servos-120","title":"5. Cinem\u00e1tica inversa de 3 servos (120\u00b0)","text":"<p>Los tres servos est\u00e1n colocados equidistantes en la base, cada uno separado 120\u00b0 del siguiente. La inclinaci\u00f3n en X e Y de la plataforma se transforma en \u00e1ngulos finales <code>A1</code>, <code>A2</code>, <code>A3</code> de cada servo usando trigonometr\u00eda:</p> <p>Se define un \u00e1ngulo base fijo:</p> <ul> <li><code>BASE_ANGLE</code> (por ejemplo, 50\u00b0) es la posici\u00f3n neutra, donde la plataforma est\u00e1 lo m\u00e1s nivelada posible.</li> <li><code>MIN_ANGLE</code> y <code>MAX_ANGLE</code> definen l\u00edmites duros (como 36\u00b0 y 63\u00b0 en <code>Slicer_grados.jpg</code>).</li> </ul> <p>En la funci\u00f3n de cinem\u00e1tica:</p> <pre><code>angle_1 = BASE_ANGLE + theta_Y\nangle_2 = BASE_ANGLE + (theta_Xcos(30\u00b0)) - (theta_Ysin(30\u00b0))\nangle_3 = BASE_ANGLE - (theta_Xcos(30\u00b0)) - (theta_Ysin(30\u00b0))\n</code></pre> <ul> <li><code>cos(30\u00b0) \u2248 0.866</code>, <code>sin(30\u00b0) = 0.5</code>.</li> <li><code>angle_1</code> responde m\u00e1s a inclinaci\u00f3n en Y (servo \u201cfrontal\u201d).</li> <li><code>angle_2</code> y <code>angle_3</code> combinan X e Y debido a la simetr\u00eda de 120\u00b0.</li> </ul> <p>Despu\u00e9s se hace <code>clip</code> de cada \u00e1ngulo entre <code>MIN_ANGLE</code> y <code>MAX_ANGLE</code>:</p> <ul> <li>As\u00ed el sistema no pide nunca un \u00e1ngulo mec\u00e1nicamente imposible para los servos.</li> </ul> <p>Las posiciones calculadas se mandan al ESP32 como:</p> <pre><code>A1:\u00e1ngulo1,A2:\u00e1ngulo2,A3:\u00e1ngulo3\\n\n</code></pre> <p>El ESP32 interpreta este string, convierte a PWM y actualiza los tres servos.</p> <p>En la ventana \u201cServo Angles\u201d (<code>Slicer_grados.jpg</code>) se pueden ajustar en vivo <code>Base</code>, <code>Min</code> y <code>Max</code>:</p> <p></p> <p>El c\u00f3digo chequea constantemente:</p> <ul> <li>Si <code>Min &gt;= Max</code>, sube <code>Max</code> autom\u00e1ticamente.</li> <li>Si <code>Base</code> sale del rango <code>[Min, Max]</code>, se corrige y se actualiza el slider.</li> </ul> <p>Cada cambio dispara el env\u00edo de una nueva configuraci\u00f3n al ESP32:</p> <pre><code>CFG:BASE:Base,MIN:Min,MAX:Max\\n\n</code></pre>"},{"location":"Tercer%20parcial/Balanza.html#6-trackbars-y-ajuste-en-tiempo-real","title":"6. Trackbars y ajuste en tiempo real","text":"<p>Las ventanas de PID y \u00e1ngulos non solo muestran sliders, sino paneles informativos generados con im\u00e1genes:</p> <ul> <li>Para PID (<code>Slicer_PID.jpg</code>): se dibuja fondo gris y texto grande \u201cKp = xx.xx, Ki = yy.yyy, Kd = zz.zz\u201d.</li> <li>Para \u00e1ngulos (<code>Slicer_grados.jpg</code>): se dibuja texto \u201cBase = 50.0 grados, Min = 36.0 grados, Max = 63.0 grados\u201d.</li> </ul> <p>De esta forma, aunque los sliders est\u00e9n arriba, el usuario ve los valores num\u00e9ricos exactos con decimales.</p>"},{"location":"Tercer%20parcial/Balanza.html#7-piezas-mecanicas-e-impresion-3d","title":"7. Piezas mec\u00e1nicas e impresi\u00f3n 3D","text":"<p>El dise\u00f1o mec\u00e1nico se basa en piezas modeladas en CAD y exportadas a STL. Se muestran varias vistas de las piezas y configuraciones de impresora, por ejemplo:</p> <ul> <li><code>Pieza_1.jpg</code>: muestra un lote de piezas peque\u00f1as (como uniones o brazos cortos) sobre la cama de impresi\u00f3n, con par\u00e1metros de capa y tiempo de impresi\u00f3n.</li> <li><code>Union_2.jpg</code>: otra pieza de uni\u00f3n m\u00e1s larga, tambi\u00e9n en Orca/Bambu Studio, donde se ve altura de capa, anchos de l\u00ednea y tiempo total.</li> <li><code>Base_servos.jpg</code>: representa la base donde se atornillan los servos, con soportes generados solo en algunas zonas verdes.</li> <li><code>Base_superior.jpg</code>: anillo o tapa superior de la plataforma, tambi\u00e9n con soportes definidos y estimaci\u00f3n de tiempo y peso de material.</li> </ul> <p>Ejemplo de c\u00f3mo documentarlas en la nota:</p> <p>  ```</p>"},{"location":"Tercer%20parcial/Balanza.html#8-codigo-completo","title":"8. Codigo completo","text":"<pre><code>import cv2\nimport numpy as np\nimport math\nimport serial\nimport time\n\n\n# ===================== CONFIGURACION SERIAL =====================\nPUERTO_SERIAL = 'COM11' # &lt;-- AJUSTA ESTO AL PUERTO DE TU ESP32\nBAUDRATE = 115200\nTIMEOUT = 0.01\n\n\ntry:\n    arduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\n    time.sleep(2)\n    print(\"\u2713 Serial conectado en\", PUERTO_SERIAL)\nexcept Exception as e:\n    print(f\"\u2717 ERROR: No se pudo conectar en {PUERTO_SERIAL}. {e}\")\n    arduino = None\n\n# ===================== PARAMETROS HOUGH (PLATO) =====================\ndp       = 0.8\nminDist  = 280\nparam1   = 165\nparam2   = 15\nminRadius = 130\nmaxRadius = 211\n\n\n# ===================== FILTRO EXPONENCIAL DEL PLATO =====================\nalpha_plato = 0.9 \nplato_cx_f = plato_cy_f = plato_r_f = None \n\n\n# ===================== COEFICIENTES DE SUAVIZADO DE ERROR =====================\nalpha_err = 0.6\nerrX_f = errY_f = 0.0 \n\n\n# ===================== VIDEO =====================\ncap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\n\n# ===================== ANGULOS DE SERVO (INICIALES) =====================\nBASE_ANGLE = 50.0 \nMIN_ANGLE = 30.0  \nMAX_ANGLE = 70.0   \n\n\nCOS_30 = math.cos(math.radians(30)) \nSIN_30 = math.sin(math.radians(30)) \n\n\n# ===================== PID BASICO =====================\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.dt = dt\n        self.prev_error = 0\n        self.integral = 0\n\n\n    def update(self, measurement):\n        error = self.setpoint - measurement\n        self.integral += error * self.dt\n        self.integral = np.clip(self.integral, -50, 50) \n        derivative = (error - self.prev_error) / self.dt\n\n        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative\n\n        output = np.clip(output, -20, 20)\n        self.prev_error = error\n        return output\n\n\n# Inicializar PIDs de inclinaci\u00f3n\npid_dt = 0.03 \npid_x = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt) \npid_y = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt)\n\n\n# ===================== CINEM\u00c1TICA DE 3 SERVOS =====================\ndef calcular_angulos_servos(theta_x, theta_y, base_angle, min_angle, max_angle):\n    angle_1 = base_angle + theta_y \n    angle_2 = base_angle + (theta_x * COS_30) - (theta_y * SIN_30)\n    angle_3 = base_angle - (theta_x * COS_30) - (theta_y * SIN_30)\n\n    angle_1 = np.clip(angle_1, min_angle, max_angle)\n    angle_2 = np.clip(angle_2, min_angle, max_angle)\n    angle_3 = np.clip(angle_3, min_angle, max_angle)\n\n    return int(angle_1), int(angle_2), int(angle_3)\n\n\n# ===================== ENVIO DE CONFIGURACION AL ESP32 =====================\ndef enviar_config_angulos(base, min_ang, max_ang):\n    \"\"\"Env\u00eda la configuraci\u00f3n de \u00e1ngulos al ESP32\"\"\"\n    if arduino is not None:\n        try:\n            comando_config = f\"CFG:BASE:{base},MIN:{min_ang},MAX:{max_ang}\\n\"\n            arduino.write(comando_config.encode('ascii'))\n            print(f\"\u2713 Config enviada: BASE={base}\u00b0, MIN={min_ang}\u00b0, MAX={max_ang}\u00b0\")\n        except Exception as e:\n            print(f\"Error al enviar config: {e}\")\n\n\n# ===================== CONFIGURACI\u00d3N DE TRACKBARS =====================\ndef on_trackbar(val):\n    pass\n\n\n# Funci\u00f3n para crear imagen de informaci\u00f3n con valores reales\ndef crear_imagen_info_pid(kp, ki, kd):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"VALORES PID ACTUALES\", (70, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Kp = {kp:.2f}\", (50, 75), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Ki = {ki:.3f}\", (50, 105), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Kd = {kd:.2f}\", (50, 135), font, 0.8, (0, 255, 255), 2)\n\n    return img\n\n\ndef crear_imagen_info_angulos(base, min_ang, max_ang):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"ANGULOS DE SERVOS\", (85, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Base = {base}.0 grados\", (50, 75), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Min  = {min_ang}.0 grados\", (50, 105), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Max  = {max_ang}.0 grados\", (50, 135), font, 0.7, (255, 165, 0), 2)\n\n    return img\n\n\n# Crear ventana de control PID\ncv2.namedWindow(\"PID Tuner\")\ncv2.resizeWindow(\"PID Tuner\", 400, 150)\n\n# Trackbars PID (sin texto de unidades, se muestra en la imagen)\ncv2.createTrackbar(\"Kp x10\", \"PID Tuner\", int(pid_x.Kp * 10), 500, on_trackbar)\ncv2.createTrackbar(\"Ki x100\", \"PID Tuner\", int(pid_x.Ki * 100), 100, on_trackbar)\ncv2.createTrackbar(\"Kd x10\", \"PID Tuner\", int(pid_x.Kd * 10), 50, on_trackbar)\n\n# Crear ventana de control de \u00c1ngulos\ncv2.namedWindow(\"Servo Angles\")\ncv2.resizeWindow(\"Servo Angles\", 400, 150)\n\n# Trackbars de \u00e1ngulos (0-180 grados)\ncv2.createTrackbar(\"Base\", \"Servo Angles\", int(BASE_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Min\", \"Servo Angles\", int(MIN_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Max\", \"Servo Angles\", int(MAX_ANGLE), 180, on_trackbar)\n\n# Enviar configuraci\u00f3n inicial\nenviar_config_angulos(int(BASE_ANGLE), int(MIN_ANGLE), int(MAX_ANGLE))\n\nprint(\"\ud83c\udfaf Detecci\u00f3n de Plato y Errores de Pelota (Fondo Negro)\")\nprint(\"\ud83d\udcd0 Ajusta los \u00e1ngulos en tiempo real con los sliders\")\nprint(\"Presiona 'q' para salir\")\n\n# Variables para detectar cambios en \u00e1ngulos\nprev_base = int(BASE_ANGLE)\nprev_min = int(MIN_ANGLE)\nprev_max = int(MAX_ANGLE)\n\n# Bucle principal de control\nwhile True:\n    # --- LECTURA Y ACTUALIZACI\u00d3N DEL PID ---\n    kp_val = cv2.getTrackbarPos(\"Kp x10\", \"PID Tuner\") / 10.0\n    ki_val = cv2.getTrackbarPos(\"Ki x100\", \"PID Tuner\") / 100.0\n    kd_val = cv2.getTrackbarPos(\"Kd x10\", \"PID Tuner\") / 10.0\n\n    pid_x.Kp, pid_x.Ki, pid_x.Kd = kp_val, ki_val, kd_val\n    pid_y.Kp, pid_y.Ki, pid_y.Kd = kp_val, ki_val, kd_val\n\n    # --- LECTURA DE \u00c1NGULOS DESDE TRACKBARS ---\n    current_base = cv2.getTrackbarPos(\"Base\", \"Servo Angles\")\n    current_min = cv2.getTrackbarPos(\"Min\", \"Servo Angles\")\n    current_max = cv2.getTrackbarPos(\"Max\", \"Servo Angles\")\n\n    # Mostrar valores reales en las ventanas de trackbars\n    img_pid_info = crear_imagen_info_pid(kp_val, ki_val, kd_val)\n    cv2.imshow(\"PID Tuner\", img_pid_info)\n\n    img_angle_info = crear_imagen_info_angulos(current_base, current_min, current_max)\n    cv2.imshow(\"Servo Angles\", img_angle_info)\n\n    # Validar que Min &lt; Base &lt; Max\n    if current_min &gt;= current_max:\n        current_max = current_min + 1\n        cv2.setTrackbarPos(\"Max\", \"Servo Angles\", current_max)\n\n    if current_base &lt; current_min:\n        current_base = current_min\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n    elif current_base &gt; current_max:\n        current_base = current_max\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n\n    # Detectar cambios y enviar nueva configuraci\u00f3n\n    if (current_base != prev_base or current_min != prev_min or current_max != prev_max):\n        enviar_config_angulos(current_base, current_min, current_max)\n        prev_base, prev_min, prev_max = current_base, current_min, current_max\n\n    # --- RESTO DE L\u00d3GICA DE VISI\u00d3N Y CONTROL ---\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    frame_display = frame.copy() \n\n    # --- 1) DETECCION DEL PLATO (HOUGH) ---\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    blurred = cv2.GaussianBlur(gray, (5,5), 0)\n    circles = cv2.HoughCircles(\n        blurred, cv2.HOUGH_GRADIENT,\n        dp=dp, minDist=minDist,\n        param1=param1, param2=param2,\n        minRadius=minRadius, maxRadius=maxRadius\n    )\n\n    plato_cx, plato_cy, plato_r = None, None, None\n\n    if circles is not None:\n        circles = np.round(circles[0, :]).astype(\"int\")\n        radios = [r for (_,_,r) in circles]\n        idx = np.argmax(radios)\n        plato_cx, plato_cy, plato_r = circles[idx]\n\n        if plato_cx_f is None:\n            plato_cx_f, plato_cy_f, plato_r_f = plato_cx, plato_cy, plato_r\n        else:\n            plato_cx_f = int(alpha_plato*plato_cx + (1-alpha_plato)*plato_cx_f)\n            plato_cy_f = int(alpha_plato*plato_cy + (1-alpha_plato)*plato_cy_f)\n            plato_r_f  = int(alpha_plato*plato_r + (1-alpha_plato)*plato_r_f)\n\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), plato_r_f, (0,255,0), 3)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), 6, (0,255,0), -1) # Centro\n\n        # --- NUEVO C\u00cdRCULO: ZONA MUERTA ---\n        DEADZONE_RADIUS = 10 # Radio en p\u00edxeles para la zona muerta (ajusta si es necesario)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), DEADZONE_RADIUS, (0,165,255), 2)\n\n        cv2.putText(frame_display, f\"PLATO DETECTADO (r={plato_r_f})\", \n                             (plato_cx_f - 120, plato_cy_f - plato_r_f - 10), \n                             cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n    else:\n        plato_cx_f = plato_cy_f = plato_r_f = None\n        cv2.putText(frame_display, \"PLATO NO DETECTADO\", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n    # --- A) ENMASCARAMIENTO CIRCULAR (FONDO NEGRO) ---\n    if plato_cx_f is not None:\n        mask_plato = np.zeros(frame.shape[:2], dtype=\"uint8\")\n        cv2.circle(mask_plato, (plato_cx_f, plato_cy_f), plato_r_f - 5, 255, -1) \n        frame_deteccion = cv2.bitwise_and(frame, frame, mask=mask_plato)\n    else:\n        frame_deteccion = frame\n\n    # --- 2) DETECCION PELOTA ROJA (COLOR / CENTROIDE) ---\n    red_low1  = np.array([0, 150, 50], np.uint8)\n    red_high1 = np.array([8, 255, 255], np.uint8)\n    red_low2  = np.array([170, 150, 50], np.uint8)\n    red_high2 = np.array([179, 255, 255], np.uint8)\n\n    hsv = cv2.cvtColor(frame_deteccion, cv2.COLOR_BGR2HSV)\n    mask1 = cv2.inRange(hsv, red_low1, red_high1)\n    mask2 = cv2.inRange(hsv, red_low2, red_high2)\n    mask = cv2.add(mask1, mask2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\n    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\n    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    mejor_c = None\n    mejor_cx = mejor_cy = 0\n    mejor_area = 0\n\n    for c in contornos:\n        area = cv2.contourArea(c)\n        if 100 &lt; area &lt; 5000:\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx = int(M[\"m10\"]/M[\"m00\"])\n                cy = int(M[\"m01\"]/M[\"m00\"])\n\n                if mejor_c is None or area &gt; mejor_area:\n                    mejor_c, mejor_cx, mejor_cy, mejor_area = c, cx, cy, area\n\n    # --- 3) CALCULO Y SUAVIZADO DE ERROR ---\n    errX_raw = 0.0\n    errY_raw = 0.0\n    pelota_detectada = False\n\n    if mejor_c is not None and plato_cx_f is not None:\n        dist_al_centro = math.hypot(mejor_cx - plato_cx_f, mejor_cy - plato_cy_f)\n\n        if dist_al_centro &lt; plato_r_f:\n            pelota_detectada = True\n\n            errX_raw = mejor_cx - plato_cx_f \n            errY_raw = mejor_cy - plato_cy_f \n\n            if plato_r_f &gt; 0:\n                 errX_norm = errX_raw / plato_r_f\n                 errY_norm = errY_raw / plato_r_f\n            else:\n                 errX_norm, errY_norm = 0.0, 0.0\n\n            errX_f = alpha_err * errX_norm + (1-alpha_err) * errX_f\n            errY_f = alpha_err * errY_norm + (1-alpha_err) * errY_f\n\n            cv2.circle(frame_display, (mejor_cx, mejor_cy), 8, (0,0,255), -1)\n            cv2.line(frame_display, (mejor_cx, mejor_cy), (plato_cx_f, plato_cy_f), (255,0,0), 2)\n\n        else:\n            errX_f, errY_f = 0.0, 0.0\n            # RESETEAR PID cuando no hay pelota\n            pid_x.integral = 0.0\n            pid_y.integral = 0.0\n            pid_x.prev_error = 0.0\n            pid_y.prev_error = 0.0\n    else:\n        errX_f, errY_f = 0.0, 0.0\n        # RESETEAR PID cuando no hay pelota\n        pid_x.integral = 0.0\n        pid_y.integral = 0.0\n        pid_x.prev_error = 0.0\n        pid_y.prev_error = 0.0\n\n    # --- 4) CONTROL PID Y ENV\u00cdO SERIAL (\ud83c\udfaf L\u00d3GICA CORREGIDA) ---\n    errX_input = errX_f * 100\n    errY_input = errY_f * 100\n\n    # Zona muerta para estabilidad\n    DEADZONE_ERR_INPUT = 5.0\n    if abs(errX_input) &lt; DEADZONE_ERR_INPUT:\n        errX_input = 0.0\n    if abs(errY_input) &lt; DEADZONE_ERR_INPUT:\n        errY_input = 0.0\n\n    # \ud83c\udfaf CORRECCI\u00d3N CLAVE: INVERTIR SE\u00d1AL DE CONTROL\n    theta_X = -pid_x.update(errX_input)  # \u2190 NEGATIVO: COMPENSA el error\n    theta_Y = -pid_y.update(errY_input)  # \u2190 NEGATIVO: COMPENSA el error\n\n    # Limitar inclinaciones extremas\n    theta_X = np.clip(theta_X, -25, 25)\n    theta_Y = np.clip(theta_Y, -25, 25)\n\n    A1, A2, A3 = calcular_angulos_servos(theta_X, theta_Y, current_base, current_min, current_max)\n\n    comando = f\"A1:{A1},A2:{A2},A3:{A3}\\n\"\n\n    if arduino is not None:\n        try:\n            arduino.write(comando.encode('ascii'))\n        except Exception as e:\n            print(f\"Error al enviar datos: {e}\")\n\n    # --- 5) HUD FINAL ---\n    font = cv2.FONT_HERSHEY_SIMPLEX\n\n    cv2.putText(frame_display, f\"Kp:{kp_val:.1f} Ki:{ki_val:.2f} Kd:{kd_val:.1f}\", \n                (10, frame_display.shape[0]-120), font, 0.5, (255,255,0), 2)\n\n    cv2.putText(frame_display, f\"Base:{current_base} Min:{current_min} Max:{current_max}\", \n                (10, frame_display.shape[0]-95), font, 0.5, (255,165,0), 2)\n\n    cv2.putText(frame_display, f\"Angulos: A1:{A1} A2:{A2} A3:{A3}\", \n                (10, frame_display.shape[0]-70), font, 0.5, (255,255,0), 2)\n\n    if pelota_detectada:\n        cv2.putText(frame_display, \n                    f'Inclinacion X,Y: ({theta_X:+.1f} deg, {theta_Y:+.1f} deg)', \n                    (10, frame_display.shape[0]-45), font, 0.5, (0,255,0), 2)\n        cv2.putText(frame_display, \n                    f'Error Norm X,Y: ({errX_f:+.2f}, {errY_f:+.2f})', \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,255,255), 2)\n    else:\n        cv2.putText(frame_display, \"PELOTA NO DETECTADA O FUERA DEL PLATO\", \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,165,255), 2)\n\n    cv2.imshow('CONTROL DE BALANZA (PID ACTIVO)', frame_display)\n    cv2.imshow('Imagen de Deteccion (Solo Plato Visible)', frame_deteccion)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\n    time.sleep(pid_dt) \n\n# ===================== LIMPIEZA =====================\nprint(\"\\n\u2713 Sistema cerrado. Centrando Servos...\")\nif arduino is not None:\n    comando_cierre = f\"A1:{current_base},A2:{current_base},A3:{current_base}\\n\"\n    arduino.write(comando_cierre.encode('ascii'))\n    time.sleep(0.5)\n    arduino.close()\n\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"Tercer%20parcial/Balanza.html#9-videos","title":"9. Videos","text":""},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html","title":"Balanza PID 3D - 6 Cuadrantes Polares","text":""},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#objetivo","title":"Objetivo","text":"<p>Crear sistema de seguimiento que divide la imagen en 6 sectores polares de 60\u00b0 m\u00e1s zonas centro superior/inferior, con slicers interactivos para filtrar \u00e1rea y control PID que env\u00eda comandos a Arduino.</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#arquitectura-dual-ventana","title":"Arquitectura Dual Ventana","text":"<p>VENTANA 1 'Camera': Video en vivo + 6 radios + detecci\u00f3n polar + PID VENTANA 2 'SLICER': Controles interactivos min/max \u00e1rea</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#1-division-polar-6-cuadrantes","title":"1. Divisi\u00f3n Polar 6 Cuadrantes","text":"<pre><code>def obtener_cuadrante_6(cx, cy, centrox, centroy):\n    dx = cx - centrox; dy = cy - centroy\n    distancia = math.sqrt(dx**2 + dy**2)\n\n    if distancia &lt; 50:  # Zona CENTRO\n        return \"CENTRO_SUP/INF\", 0.0, 0.0, color_amarillo/cyan\n\n    angulo = math.atan2(dy, dx) * 180 / math.pi  # 0\u00b0=derecha\n    if angulo &lt; 0: angulo += 360\n    sector = int(angulo // 60)  # 6 sectores 60\u00b0\n</code></pre> <p>Sectores: 0\u00b0(Der-Rojo), 60\u00b0(Naranja), 120\u00b0(Magenta), 180\u00b0(Cian), 240\u00b0(Rosa), 300\u00b0(Verde)</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#2-errores-normalizados-polares","title":"2. Errores Normalizados Polares","text":"<pre><code>error_magnitud = np.clip(distancia / 250, 0, 1.0)  # 0=centro, 1=borde\nerrorX_norm = (dx / distancia) * error_magnitud\nerrorY_norm = (dy / distancia) * error_magnitud\n</code></pre> <p>Vector unitario \u00d7 magnitud: Error direccional ponderado por distancia.</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#3-comunicacion-serial-arduino","title":"3. Comunicaci\u00f3n Serial Arduino","text":"<pre><code>PUERTO_SERIAL = 'COM11'; BAUDRATE = 11520\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=0.01)\ntime.sleep(2)  # Reset Arduino\n</code></pre> <p>Comando: \"X:45,Y:-12,Z:78\\n\" \u2192 Servos pines 11,6,5</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#4-controladores-pid-3-ejes","title":"4. Controladores PID (3 ejes)","text":"<pre><code>pid_x = PID(Kp=0.8, Ki=0.05, Kd=0.15)     # Horizontal\npid_y = PID(Kp=0.8, Ki=0.05, Kd=0.15)     # Vertical\npid_area = PID(Kp=0.3, Ki=0.02, Kd=0.08, setpoint=2000)  # Distancia\n</code></pre> <p>Escalado: errorX_norm * 100 \u2192 salida \u00b190\u00b0 servo</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#5-slicers-interactivos-minmax-area","title":"5. Slicers Interactivos (min/max \u00e1rea)","text":"<pre><code>def dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color):\n    cv2.rectangle(frame, (10, y_pos), (310, y_pos+30), (50,50,50), -1)  # Fondo\n    proporcion = (valor - min_val) / (max_val - min_val)\n    cv2.rectangle(frame, (10, y_pos), (10+int(proporcion*300), y_pos+30), color, -1)\n</code></pre> <p>Controles: Rueda mouse \u2191\u2193 | A/Z:min\u00b1100 | S/X:max\u00b1200</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#6-deteccion-visual-optimizada","title":"6. Detecci\u00f3n Visual Optimizada","text":"<pre><code>hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nmask1 = cv2.inRange(hsv, [0,150,50], [8,255,255])     # Rojo1\nmask2 = cv2.inRange(hsv, [170,150,50], [179,255,255]) # Rojo2\nmask = cv2.add(mask1, mask2)\n</code></pre> <p>Filtro \u00e1rea: min_area(100)-max_area(8000) elimina ruido/objetos grandes</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#7-visualizacion-6-radios-polares","title":"7. Visualizaci\u00f3n 6 Radios Polares","text":"<pre><code>radio_lineas = 150\nfor angulo in range(0, 360, 60):  # Cada 60\u00b0\n    x_fin = centrox + radio_lineas * math.cos(math.radians(angulo))\n    y_fin = centroy + radio_lineas * math.sin(math.radians(angulo))\n    cv2.line(frame, (centrox, centroy), (x_fin, y_fin), (0,255,0), 2)\n</code></pre> <p>6 l\u00edneas verdes: Dividen imagen en sectores polares precisos.</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#8-flujo-principal-dual-ventana","title":"8. Flujo Principal Dual Ventana","text":"<pre><code>while True:\n    frame = cap.read() \u2192 flip(1)\n    # 1. HSV \u2192 Morfolog\u00eda \u2192 Contornos filtrados\n    # 2. Mejor contorno \u2192 cuadrante_6() \u2192 errores normalizados\n    # 3. PID \u2192 outputX/Y/Z \u2192 Serial Arduino\n    # 4. Dibujar: centro+radio50+6lineas+target+cuadrante\n    # 5. frame_slicer \u2192 2 slicers + cursor mouse\n    cv2.imshow('Camera', frame)\n    cv2.imshow('SLICER', frame_slicer)\n</code></pre>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#9-controles-interactivos-completos","title":"9. Controles Interactivos Completos","text":"<p>TECLADO: A/Z: min_area \u00b1100 S/X: max_area \u00b1200 Q: Salir</p> <p>RAT\u00d3N (ventana SLICER): \u2191\u2193Rueda sobre slicer1: min_area \u00b150 \u2191\u2193Rueda sobre slicer2: max_area \u00b1100</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#10-informacion-en-pantalla-tiempo-real","title":"10. Informaci\u00f3n en Pantalla Tiempo Real","text":"<p>CENTRO: C\u00edrculo verde r=10 + borde r=50 (zona CENTRO) TARGET: C\u00edrculo coloreado por cuadrante r=8 RADIO: 6 l\u00edneas verdes 150px cada 60\u00b0 TEXTO: Cuadrante | X/Y_norm | \u00c1rea | PID_XYZ SLICER: min_area(verde) | max_area(naranja)</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#11-limpieza-segura","title":"11. Limpieza Segura","text":"<pre><code>arduino.write(b\"X:0,Y:0,Z:0\\n\")  # Servos neutral\ntime.sleep(0.5)  # Movimiento completo\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#valores-iniciales-recomendados","title":"Valores Iniciales Recomendados","text":"<p>min_area = 100    # Elimina ruido peque\u00f1o max_area = 8000   # Limita objetos grandes setpoint_area = 2000  # Tama\u00f1o objetivo pelota radio_centro = 50     # Zona muerta central radio_lineas = 150    # Visualizaci\u00f3n sectores</p>"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#problemas-comunes-y-soluciones","title":"Problemas Comunes y Soluciones","text":"Problema Causa Soluci\u00f3n No detecta \u00c1rea fuera rango Ajustar slicers A/Z/S/X Cuadrante err\u00f3neo Pelota en borde \u2191radio_centro (60-80) PID inestable Error muy peque\u00f1o errorX_norm * 150 Servos no responden Serial Verificar COM11/11520"},{"location":"Tercer%20parcial/Calibracion%20cuadrantes.html#evidencias","title":"Evidencias","text":""},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html","title":"Calibrador HoughCircles - Plato Circular","text":""},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#objetivo","title":"Objetivo","text":"<p>Crear una interfaz interactiva que permita ajustar en tiempo real los 6 par\u00e1metros de cv2.HoughCircles para detectar platos circulares de forma \u00f3ptima, guardando valores finales para c\u00f3digo principal.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#parametros-houghcircles-explicados","title":"Par\u00e1metros HoughCircles Explicados","text":"Par\u00e1metro Funci\u00f3n Rango t\u00edpico Efecto visual dp Resoluci\u00f3n acumulador (1=imagen, 2=mitad) 0.8-2.0 Precisi\u00f3n vs velocidad minDist Distancia m\u00ednima c\u00edrculos 100-400px Evita detecci\u00f3n m\u00faltiple param1 Umbral Canny (bordes) 50-200 Sensibilidad bordes param2 Umbral acumulador c\u00edrculo 15-60 Confianza detecci\u00f3n minRadius Radio m\u00ednimo c\u00edrculo 80-200px Filtra c\u00edrculos peque\u00f1os maxRadius Radio m\u00e1ximo c\u00edrculo 200-400px Filtra c\u00edrculos grandes"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#1-inicializacion-y-ventana-interactiva","title":"1. Inicializaci\u00f3n y Ventana Interactiva","text":"<pre><code>cap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nventana_calibrador = 'HOUGH CIRCLES CALIBRADOR'\ncv2.namedWindow(ventana_calibrador)\ncv2.setMouseCallback(ventana_calibrador, mouse_callback)\n</code></pre> <ul> <li>640x480: Resoluci\u00f3n fija para slicers consistentes</li> <li>mouse_callback: Detecta rueda del mouse sobre slicers</li> </ul>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#2-frame-slicers-panel-de-control","title":"2. Frame Slicers (Panel de Control)","text":"<pre><code>frame_slicers = np.zeros((480, 640, 3), dtype=np.uint8)\nframe_slicers.fill(30)  # Fondo gris oscuro\n</code></pre> <p>Crea panel negro separado (mismo tama\u00f1o c\u00e1mara) para 6 slicers horizontales.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#3-funcion-dibujar_slicer","title":"3. Funci\u00f3n dibujar_slicer()","text":"<pre><code>def dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color):\n    # Barra fondo gris\n    cv2.rectangle(frame, (20, y_pos), (620, y_pos+35), (60,60,60), -1)\n    # Barra progreso coloreada\n    proporcion = (valor - min_val) / (max_val - min_val)\n    ancho_activo = int(proporcion * 600)\n    cv2.rectangle(frame, (20, y_pos+5), (20+ancho_activo, y_pos+30), color, -1)\n    # Etiqueta con valor actual\n    cv2.putText(frame, f'{label}: {valor:.1f}', (20, y_pos-8), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n</code></pre> <p>Cada slicer: Barra gris + progreso coloreado + texto valor/rango.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#4-deteccion-houghcircles-en-tiempo-real","title":"4. Detecci\u00f3n HoughCircles en Tiempo Real","text":"<pre><code>gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\nblurred = cv2.GaussianBlur(gray, (5, 5), 0)  # Suavizado esencial\n\ncircles = cv2.HoughCircles(\n    blurred, cv2.HOUGH_GRADIENT, \n    dp=float(dp), minDist=int(minDist),\n    param1=int(param1), param2=int(param2),\n    minRadius=int(minRadius), maxRadius=int(maxRadius)\n)\n</code></pre> <p>GaussianBlur(5,5): Elimina ruido antes de Hough (cr\u00edtico).</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#5-seleccion-mejor-circulo","title":"5. Selecci\u00f3n Mejor C\u00edrculo","text":"<pre><code>if circles is not None:\n    circles = np.round(circles[0, :]).astype(\"int\")\n    areas = [r*r for _,_,r in circles]  # \u00c1rea = \u03c0r\u00b2 \u2248 r\u00b2\n    mejor_idx = np.argmax(areas)  # MAYOR = m\u00e1s confiable\n    mejor_plato = circles[mejor_idx]\n</code></pre> <p>Criterio: El c\u00edrculo de mayor radio es el plato principal.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#6-visualizacion-inteligente","title":"6. Visualizaci\u00f3n Inteligente","text":""},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#todos-los-circulos-transparencia-por-confianza","title":"TODOS los c\u00edrculos (transparencia por confianza)","text":"<pre><code>for i, (x, y, r) in enumerate(circles):\n    alpha = 0.3 + 0.7 * (r*r / max(areas))  # Mayor \u00e1rea = m\u00e1s visible\n    color = (0, int(255*alpha), 0)\n    cv2.circle(frame, (x, y), r, color, 2)\n\n# MEJOR PLATO (verde grueso)\ncv2.circle(frame, (x, y), r, (0,255,0), 3)\ncv2.circle(frame, (x, y), 6, (0,255,0), -1)\n</code></pre> <p>Alpha din\u00e1mico: C\u00edrculos peque\u00f1os semitransparentes, grandes=opacos.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#7-controles-interactivos","title":"7. Controles Interactivos","text":""},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#rueda-del-mouse-sobre-slicers","title":"Rueda del Mouse (sobre slicers)","text":"<pre><code>if event == cv2.EVENT_MOUSEWHEEL:\n    delta = 0.05 if event &gt; 0 else -0.05\n    if y_slicer &lt;= y &lt;= y_slicer+33:  # Zona DP\n        dp = np.clip(dp + delta, 0.8, 2.0)\n</code></pre>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#teclado-rapido","title":"Teclado r\u00e1pido","text":"<p>Q/A: dp \u00b10.1    D/E: minDist \u00b120 Z/X: param1 \u00b110  C/V: param2 \u00b15 B/N: minR \u00b110    ,/.: maxR \u00b120 ESPACIO: Guardar  ESC: Salir</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#8-interfaz-combinada","title":"8. Interfaz Combinada","text":"<pre><code>frame_combinado = np.hstack([frame, frame_slicers])  # Izquierda=Derecha\ncv2.imshow(ventana_calibrador, frame_combinado)\n</code></pre> <p>hstack: C\u00e1mara (640px) + Slicers (640px) = 1280px ancho.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#9-guardado-valores-optimos","title":"9. Guardado Valores \u00d3ptimos","text":"<pre><code>if tecla == 32:  # ESPACIO\n    valores_optimos = {'dp': dp, 'minDist': minDist, ...}\n    print(\"\u2705 VALORES \u00d3PTIMOS GUARDADOS:\")\n</code></pre> <p>Salida lista para copiar a c\u00f3digo principal HoughCircles.</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#10-valores-iniciales-recomendados","title":"10. Valores Iniciales Recomendados","text":"<p>dp = 1.2        # Resoluci\u00f3n media minDist = 200   # Platos ~20cm separados param1 = 100    # Bordes medios param2 = 30     # Confianza media minRadius = 120 # Platos ~12cm di\u00e1metro maxRadius = 300 # Hasta ~30cm</p>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#uso-practico","title":"Uso Pr\u00e1ctico","text":"<ol> <li>Ejecutar calibrador \u2192 apuntar c\u00e1mara a platos</li> <li>Ajustar slicers con rueda/teclado hasta detectar 1 c\u00edrculo verde grueso</li> <li>ESPACIO \u2192 copiar valores impresos</li> <li>Pegar en c\u00f3digo principal:</li> </ol> <pre><code>circles = cv2.HoughCircles(blurred, cv2.HOUGH_GRADIENT, \n    dp=1.2, minDist=200, param1=100, param2=30, \n    minRadius=120, maxRadius=300)\n</code></pre>"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#problemas-comunes","title":"Problemas Comunes","text":"S\u00edntoma Soluci\u00f3n Demasiados c\u00edrculos \u2191minDist, \u2193param2 No detecta plato \u2193param1, \u2191param2, \u2193dp C\u00edrculos muy peque\u00f1os \u2191minRadius Demasiado lento \u2191dp (1.5-2.0) Bordes ruidosos GaussianBlur(7,7)"},{"location":"Tercer%20parcial/Calibracion%20de%20plataforma.html#evidencias","title":"Evidencias","text":""},{"location":"Tercer%20parcial/Open%20cv.html","title":"Balanza PID 3D - OpenCV + Arduino","text":""},{"location":"Tercer%20parcial/Open%20cv.html#objetivo","title":"Objetivo","text":"<p>Crear una plataforma aut\u00f3noma que siga un objeto de color espec\u00edfico moviendo 3 servos usando visi\u00f3n por computadora y control PID avanzado.</p>"},{"location":"Tercer%20parcial/Open%20cv.html#1-inicializacion-camara-cv2videocapture","title":"1. Inicializaci\u00f3n C\u00e1mara (cv2.VideoCapture)","text":""},{"location":"Tercer%20parcial/Open%20cv.html#por-que-videocapture0","title":"\u00bfPor qu\u00e9 VideoCapture(0)?","text":"<pre><code>cap = cv2.VideoCapture(0) # 0 = c\u00e1mara predeterminada (webcam)\n</code></pre> <ul> <li><code>0</code> = primera c\u00e1mara detectada (webcam USB/interna)</li> <li><code>1</code> = segunda c\u00e1mara, etc.</li> <li>IMPORTANTE: Siempre cerrar con <code>cap.release()</code> para liberar el dispositivo</li> </ul>"},{"location":"Tercer%20parcial/Open%20cv.html#ciclo-de-vida-camara","title":"Ciclo de vida c\u00e1mara","text":"<pre><code>\u2705 CORRECTO\ncap = cv2.VideoCapture(0)\nwhile True:\nret, frame = cap.read() # ret=True si lee bien\nif not ret: break\n\n...\ncap.release() # Libera c\u00e1mara para otras apps\ncv2.destroyAllWindows() # Cierra ventanas OpenCV\n\n\u274c ERROR: C\u00e1mara queda \"bloqueada\"\ncap = cv2.VideoCapture(0)\nwhile True:\nret, frame = cap.read()\n# Sin release() \u2192 otras apps no acceden c\u00e1mara\n</code></pre>"},{"location":"Tercer%20parcial/Open%20cv.html#2-comunicacion-serial-completa","title":"2. Comunicaci\u00f3n Serial Completa","text":""},{"location":"Tercer%20parcial/Open%20cv.html#inicializacion-robusta","title":"Inicializaci\u00f3n robusta","text":"<pre><code>PUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\ntry:\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\ntime.sleep(2) # Arduino necesita 2s para reset+boot\nprint(\"\u2713 Serial conectado\")\nexcept:\nprint(\"\u2717 Puerto no disponible\")\nexit()\n</code></pre> <p>time.sleep(2): Arduino hace reset al conectar USB, necesita tiempo para cargar sketch.</p>"},{"location":"Tercer%20parcial/Open%20cv.html#envio-de-comandos","title":"Env\u00edo de comandos","text":"<pre><code>comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\narduino.write(comando.encode()) # String \u2192 bytes\n</code></pre> <ul> <li><code>\\n</code> = terminador necesario para <code>readStringUntil('\\n')</code> en Arduino</li> <li><code>encode()</code> convierte string Python a bytes seriales</li> </ul>"},{"location":"Tercer%20parcial/Open%20cv.html#cierre-seguro","title":"Cierre seguro","text":"<pre><code>Antes de salir\narduino.write(b\"X:0,Y:0,Z:0\\n\") # Servos a posici\u00f3n segura\ntime.sleep(0.5) # Servo llega a posici\u00f3n\narduino.close() # Libera puerto serial\n</code></pre>"},{"location":"Tercer%20parcial/Open%20cv.html#3-clase-pid-explicacion-matematica","title":"3. Clase PID - Explicaci\u00f3n Matem\u00e1tica","text":"<pre><code>class PID:\ndef update(self, measurement):\nerror = self.setpoint - measurement # Error actual\n</code></pre> <pre><code>self.integral += error * self.dt     # \u2211error\u00b7\u0394t (acumula)\nself.integral = np.clip(self.integral, -50, 50)  # Anti-windup\n\nderivative = (error - self.prev_error) / self.dt  # \u0394error/\u0394t\nself.output = (self.Kp*error + \n              self.Ki*self.integral + \n              self.Kd*derivative)\nself.output = np.clip(self.output, -90, 90)  # L\u00edmite servo\n\nself.prev_error = error\nreturn self.output\n</code></pre> <p>np.clip(): Evita que servos vayan m\u00e1s all\u00e1 de l\u00edmites f\u00edsicos.</p>"},{"location":"Tercer%20parcial/Open%20cv.html#4-deteccion-hsv-por-que-dos-rangos-para-rojo","title":"4. Detecci\u00f3n HSV - \u00bfPor qu\u00e9 dos rangos para rojo?","text":"<pre><code>Rojo envuelve H=0\u00b0 y H=180\u00b0 (c\u00edrculo HSV)\nredbajo1 = np.array() # Rojo inicial (0-8)\u200b\nredalto1 = np.array()\nredbajo2 = np.array() # Rojo final (170-179)\u200b\nredalto2 = np.array()\nmask = cv2.add(mask1, mask2) # Combina ambos\n</code></pre> <p>S=150, V=50: Filtra rojos saturados y brillantes, elimina sombras/grises.</p>"},{"location":"Tercer%20parcial/Open%20cv.html#5-procesamiento-morfologico","title":"5. Procesamiento Morfol\u00f3gico","text":"<pre><code>kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\nmask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel) # Elimina ruido\nmask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel) # Une huecos\n</code></pre> <ul> <li>OPEN: Erosi\u00f3n \u2192 Dilataci\u00f3n = elimina puntos sueltos</li> <li>CLOSE: Dilataci\u00f3n \u2192 Erosi\u00f3n = une regiones separadas</li> <li>ELLIPSE: M\u00e1s suave que rect\u00e1ngulo</li> </ul>"},{"location":"Tercer%20parcial/Open%20cv.html#6-seleccion-mejor-contorno","title":"6. Selecci\u00f3n Mejor Contorno","text":"<pre><code>for c in contornos:\narea = cv2.contourArea(c)\nif 100 &lt; area &lt; 8000: # Filtra ruido/objetos grandes\nM = cv2.moments(c)\nif M[\"m00\"] != 0: # \u00c1rea v\u00e1lida\ncx = int(M[\"m10\"] / M[\"m00\"]) # Centro X\ncy = int(M[\"m01\"] / M[\"m00\"]) # Centro Y\nif area &gt; mejor_area: # Mayor = objetivo principal\nmejor_contorno = c\n</code></pre> <p>m00=0: Contorno con \u00e1rea cero (inv\u00e1lido).</p>"},{"location":"Tercer%20parcial/Open%20cv.html#7-filtro-exponencial-estabilidad","title":"7. Filtro Exponencial (Estabilidad)","text":"<pre><code>alpha = 0.6 # 60% nuevo, 40% anterior\nerrorX = alpha * errorX_raw + (1-alpha) * prev_errorX\n</code></pre> <p>Ejemplo: Error raw: 10\u219250\u2192-20 \u2192 Filtrado: 10\u219228\u219216 (suave).</p>"},{"location":"Tercer%20parcial/Open%20cv.html#8-bucle-principal-explicado","title":"8. Bucle Principal Explicado","text":"<pre><code>while True:\nret, frame = cap.read()\nif not ret: break # C\u00e1mara desconectada\n</code></pre> <p>frame = cv2.flip(frame, 1)  # Espejo (intuitivo) centrox = frame.shape // 2  # Centro ancho[2] centroy = frame.shape // 2  # Centro alto</p>"},{"location":"Tercer%20parcial/Open%20cv.html#deteccion-hsv-pid-serial-visualizar","title":"[Detecci\u00f3n HSV \u2192 PID \u2192 Serial \u2192 Visualizar]","text":"<p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):  # ESC o 'q'     break</p> <p>waitKey(1): 1ms delay, ~1000 FPS m\u00e1ximo (limitado por c\u00e1mara).</p>"},{"location":"Tercer%20parcial/Open%20cv.html#9-visualizacion-informativa","title":"9. Visualizaci\u00f3n Informativa","text":"<pre><code>cv2.circle(frame, (centrox, centroy), 8, (0,255,0), -1) # Centro VERDE\ncv2.circle(frame, (mejor_cx, mejor_cy), 7, (0,0,255), -1) # Target ROJO\ncv2.drawContours(frame, [hull], 0, (255,255,0), 2) # Contorno CYAN\ncv2.putText(frame, f'X11:{int(outputX)}', ...) # Valores PID\n</code></pre>"},{"location":"Tercer%20parcial/Open%20cv.html#10-limpieza-final-critica","title":"10. Limpieza Final (CR\u00cdTICA)","text":"<pre><code>1. Servos a posici\u00f3n segura\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5) # Servo se mueve\n\n2. Liberar recursos\ncap.release() # C\u00e1mara libre para otras apps\narduino.close() # Puerto serial libre\ncv2.destroyAllWindows() # Cierra todas ventanas OpenCV\n</code></pre> <p>Sin release(): C\u00e1mara queda bloqueada, serial ocupado.</p>"},{"location":"Tercer%20parcial/Open%20cv.html#codigo-arduino-completo","title":"C\u00f3digo Arduino Completo","text":"<pre><code>#include &lt;Servo.h&gt;\nServo servoX(11), servoY(6), servoZ(5);\n\nvoid setup() {\nSerial.begin(11520);\nservoX.write(90); servoY.write(90); servoZ.write(90); // Neutral\n}\n\nvoid loop() {\nif (Serial.available()) {\nString cmd = Serial.readStringUntil('\\n');\n// Parsing robusto con \u00edndices\nint x = cmd.substring(cmd.indexOf(\"X:\")+2, cmd.indexOf(\",Y\")).toInt();\nservoX.write(map(x, -90,90,0,180));\n}\n}\n</code></pre> <p>int x = cmd.substring(idxX, cmd.indexOf(\",\", idxX)).toInt(); int y = cmd.substring(idxY, cmd.indexOf(\",\", idxY)).toInt(); int z = cmd.substring(idxZ).toInt();</p> <p>servoX.write(map(x, -90, 90, 0, 180)); servoY.write(map(y, -90, 90, 0, 180)); servoZ.write(map(z, -90, 90, 0, 180));</p>"},{"location":"Tercer%20parcial/Open%20cv.html#tabla-hsv-por-color-objetivo","title":"Tabla HSV por Color Objetivo","text":"Color H_bajo1 H_alto1 H_bajo2 H_alto2 S_min V_min Rojo 0 8 170 179 150 50 Verde 50 75 - - 100 50 Azul 100 130 - - 100 50 Amarillo 20 35 - - 150 100 Naranja 10 25 - - 150 100 P\u00farpura 140 160 - - 100 50 Rosa 160 175 - - 100 100 Cian 80 100 - - 100 100 <p>Uso: Reemplazar rangos rojo por el color deseado en el c\u00f3digo.</p>"},{"location":"Tercer%20parcial/Open%20cv.html#codigo-python-completo","title":"C\u00f3digo Python Completo","text":""},{"location":"Tercer%20parcial/Open%20cv.html#import-cv2-import-numpy-as-np-import-serial-import-serialtoolslist_ports-import-time-puerto_serial-com11-baudrate-11520-timeout-001-try-arduino-serialserialpuerto_serial-baudrate-timeouttimeout-timesleep2-print-serial-conectado-except-print-error-puerto-exit-class-pid-def-initself-kp-ki-kd-setpoint0-dt003-selfkp-kp-selfki-ki-selfkd-kd-selfsetpoint-setpoint-selfdt-dt-selfprev_error-0-selfintegral-0-selfoutput-0-def-updateself-measurement-error-selfsetpoint-measurement-selfintegral-error-selfdt-selfintegral-npclipselfintegral-50-50-derivative-error-selfprev_error-selfdt-selfoutput-selfkperror-selfkiselfintegral-selfkdderivative-selfoutput-npclipselfoutput-90-90-selfprev_error-error-return-selfoutput-pid_x-pid08-005-015-pid_y-pid08-005-015-pid_area-pid03-002-008-setpoint2000-cap-cv2videocapture0-alpha-06-prev_errorx-prev_errory-0-0-print-balanza-pid-3d-while-true-ret-frame-capread-if-not-ret-break-frame-cv2flipframe-1-centrox-frameshape-22-centroy-frameshape-2-hsv-cv2cvtcolorframe-cv2color_bgr2hsv-redbajo1-nparray-redalto1-nparray1-redbajo2-nparray-redalto2-nparray1-mask1-cv2inrangehsv-redbajo1-redalto1-mask2-cv2inrangehsv-redbajo2-redalto2-mask-cv2addmask1-mask2-kernel-cv2getstructuringelementcv2morph_ellipse-55-mask-cv2morphologyexmask-cv2morph_open-kernel-mask-cv2morphologyexmask-cv2morph_close-kernel-contornos-_-cv2findcontoursmask-cv2retr_external-cv2chain_approx_simple-mejor_contorno-none-mejor_cx-mejor_cy-mejor_area-none-none-0-for-c-in-contornos-area-cv2contourareac-if-100-area-8000-m-cv2momentsc-if-mm00-0-cx-intmm10-mm00-cy-intmm01-mm00-if-area-mejor_area-mejor_contorno-c-mejor_cx-mejor_cy-cx-cy-mejor_area-area-if-mejor_contorno-is-not-none-errorx_raw-mejor_cx-centrox-errory_raw-mejor_cy-centroy-errorx-alpha-errorx_raw-1-alpha-prev_errorx-errory-alpha-errory_raw-1-alpha-prev_errory-prev_errorx-prev_errory-errorx-errory-outputx-pid_xupdateerrorx-outputy-pid_yupdateerrory-outputarea-pid_areaupdatemejor_area-comando-fxintoutputxyintoutputyzintoutputarean-arduinowritecomandoencode-cv2circleframe-intmejor_cx-intmejor_cy-7-00255-1-hull-cv2convexhullmejor_contorno-cv2drawcontoursframe-hull-0-2552550-2-else-arduinowritebx0y0z0n-cv2circleframe-centrox-centroy-8-02550-1-cv2imshowbalanza-pid-3d-frame-if-cv2waitkey1-0xff-ordq-break-arduinowritebx0y0z0n-timesleep05-caprelease-arduinoclose-cv2destroyallwindows-print-sistema-cerrado","title":"<pre><code>import cv2\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\nimport time\n\nPUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\ntry:\narduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\ntime.sleep(2)\nprint(\"\u2713 Serial conectado\")\nexcept:\nprint(\"\u2717 ERROR puerto\")\nexit()\n\nclass PID:\ndef init(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\nself.Kp = Kp; self.Ki = Ki; self.Kd = Kd\nself.setpoint = setpoint; self.dt = dt\nself.prev_error = 0; self.integral = 0; self.output = 0\n\ndef update(self, measurement):\n    error = self.setpoint - measurement\n    self.integral += error * self.dt\n    self.integral = np.clip(self.integral, -50, 50)\n    derivative = (error - self.prev_error) / self.dt\n    self.output = self.Kp*error + self.Ki*self.integral + self.Kd*derivative\n    self.output = np.clip(self.output, -90, 90)\n    self.prev_error = error\n    return self.output\n\npid_x = PID(0.8, 0.05, 0.15)\npid_y = PID(0.8, 0.05, 0.15)\npid_area = PID(0.3, 0.02, 0.08, setpoint=2000)\n\ncap = cv2.VideoCapture(0)\nalpha = 0.6\nprev_errorX, prev_errorY = 0, 0\n\nprint(\"\ud83c\udfaf BALANZA PID 3D\")\nwhile True:\nret, frame = cap.read()\nif not ret: break\n\nframe = cv2.flip(frame, 1)\ncentrox = frame.shape // 2[2]\ncentroy = frame.shape // 2\n\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nredbajo1 = np.array(); redalto1 = np.array()[1]\nredbajo2 = np.array(); redalto2 = np.array()[1]\n\nmask1 = cv2.inRange(hsv, redbajo1, redalto1)\nmask2 = cv2.inRange(hsv, redbajo2, redalto2)\nmask = cv2.add(mask1, mask2)\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\nmask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\nmask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\ncontornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\nmejor_contorno = None; mejor_cx, mejor_cy, mejor_area = None, None, 0\n\nfor c in contornos:\n    area = cv2.contourArea(c)\n    if 100 &lt; area &lt; 8000:\n        M = cv2.moments(c)\n        if M[\"m00\"] != 0:\n            cx = int(M[\"m10\"] / M[\"m00\"])\n            cy = int(M[\"m01\"] / M[\"m00\"])\n            if area &gt; mejor_area:\n                mejor_contorno = c\n                mejor_cx, mejor_cy = cx, cy\n                mejor_area = area\n\nif mejor_contorno is not None:\n    errorX_raw = mejor_cx - centrox\n    errorY_raw = mejor_cy - centroy\n    errorX = alpha * errorX_raw + (1-alpha) * prev_errorX\n    errorY = alpha * errorY_raw + (1-alpha) * prev_errorY\n    prev_errorX, prev_errorY = errorX, errorY\n\n    outputX = pid_x.update(errorX)\n    outputY = pid_y.update(errorY)\n    outputArea = pid_area.update(mejor_area)\n\n    comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\n    arduino.write(comando.encode())\n\n    cv2.circle(frame, (int(mejor_cx), int(mejor_cy)), 7, (0,0,255), -1)\n    hull = cv2.convexHull(mejor_contorno)\n    cv2.drawContours(frame, [hull], 0, (255,255,0), 2)\nelse:\n    arduino.write(b\"X:0,Y:0,Z:0\\n\")\n\ncv2.circle(frame, (centrox, centroy), 8, (0,255,0), -1)\ncv2.imshow('BALANZA PID 3D', frame)\n\nif cv2.waitKey(1) &amp; 0xFF == ord('q'): break\n\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5)\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\nprint(\"\u2713 Sistema cerrado\")\n</code></pre>","text":""},{"location":"Tercer%20parcial/Open%20cv.html#evidencias","title":"Evidencias","text":""}]}